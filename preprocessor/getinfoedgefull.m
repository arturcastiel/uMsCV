
%--------------------------------------------------------------------------
%FUNCTION "getinfoedge"
%--------------------------------------------------------------------------
%This is a modified version of the  original getinfoedge function. 
%It changes the way getinfo work to enable reading multi-scale meshes
%--------------------------------------------------------------------------
%                                   INPUT
%--------------------------------------------------------------------------
% coord - coordinate matrix
% elem - elemen matrix
% nnode - number of node-type element
% nbe - number of edge-type elements in the boundary
% nelem - number of 2d shaped elements
% veryfymshfile - pointer to MSH file
% nnode - number of nodes
% intnode - node-type entities located inside the mesh
% flaglim - vector with internal node flags
% nodelim - node-type entity on the boundary
% meshtype - flag: true - multiscale mesh / false: FEM mesh
% bcflag - matrix with boundary conditions flag from start.dat
%--------------------------------------------------------------------------
%                                   OUPUT
%--------------------------------------------------------------------------
%
% bedge - edges on the boundary
%   node1 node2 element-associate - boundary condition
% inedge - edges inside the domain
%   node1 node2 leftelement rightelement

function [bedge,inedge,klb] = getinfoedgefull(coord,elem,nnode,nbe,nelem,...
    nodelim,intnode,flaglim,verifymshfile,bcflag,meshtype)

%"bedge" and "inedge" matrix - Contain respectively the node who constitute
%the boundary edges and iner edges, besides the element which contain such 
%nodes. In case of internal nodes "Inedge" offers the node to both left and 
%right side to edge evaluated 

%The number of external edge (where the boundary conditions are applieds) 
%may be obtained throughout *.msh generated by gmsh.
    
%"bedge" is a matrix which contain the two nodes which constitute each 
%external edge, the element which edge belongs and a geometric flag

%Create and initialize "bedgeaux" matrix. Its order is (nbe x 5). 
%"nbe" is the number of boundary edges. The first two columns are the nodes 
%which constitute the edge. The third node is the element which the edge 
%belongs (element to left). The last columns is the boundary condition's 
%type (Dirichlet or Neumann) flag. 
bedgeaux = zeros(nbe,5);

%Create and initialize "inedge". In principle the number of rows is not
%known. To long of fulfill of that we will know its row amount.
%However its column number is known. The two firsts values are the nodes
%who defines the edge. The two last values are respectively the left and
%right elements with regard to edge evaluated
inedge = zeros(1,4);

%Fill the matrix "bedge" with a boundary condition flag and the two nodes 
%which constitute it

%Open the *.msh file
readbound = fopen(verifymshfile);

%In principle "bedgeaux" read in its fourth column the geometry flag from 
%*.msh file generated by gmsh. After that "bedge" receives this info.
getboundata = textscan(readbound,'%*u %*u %*u %u %*u %u %u %u %u',nbe,...
    'HeaderLines',8 + nnode + nodelim + intnode);

%Attribute the data to "bedgeaux"
%debug
auxmat = cell2mat(getboundata); 
if meshtype == false
    auxmat(:,end-1:end) = [];
end

bedgeaux(:,5) = auxmat(:,1);
bedgeaux(:,1:2) = [auxmat(:,end-1) auxmat(:,end)];



clear getboundata auxmat


%Close file
fclose(readbound);

%Fills "bedge" according to value in its fifth column:
%It points the correct row in "bedgeaux"
pntcorrectrow = ismember(bedgeaux(:,5),bcflag(:,1));
%Fill "bedge"
bedge = bedgeaux(pntcorrectrow,:);

klb = 0;
%Verify how many rows in "bedge" has known Neumann Boundary condition.
%Get the flag that feature a Neumann NON-Null boundary
%debug

pointflag = logical(bcflag(:,1) > 200 & bcflag(:,2) ~= 0);
%Define the "flagval"
flagval = bcflag(pointflag,1);
%For each non-null flag, we verify the row number and store this in "klb"
%(Known Line Boundary)
if any(pointflag)
    bedgnumrow = 1:size(bedge,1);
    %Swept the non-null bc.
    for i = 1:length(flagval)
        %Point to "bedge" row
        boundpoint = logical(bedge(:,5) == flagval(i));
        klb = union(klb,bedgnumrow(boundpoint));
    end  %End of FOR
    klb = klb(2:length(klb));
end  %End of IF
        
%Fill the fourth column, which receive the boundary code related to first 
%point of each element. The second point is always the first one of behind 
%row. Thus, the fourth column receives the values of the fiveth column.
bedge(:,4) = bedge(:,5);

%The nodes which was marked with a different bounday condition will be
%ajusted below.
%"nodelim" is the amount of nodes over the boundary
%"flaglim" stores the flags associated to the external nodes
for ipoint = 1:nodelim
    %"rowmod" are the rows which will be modified
    rowmod = logical(bedge(:,1) == ipoint);
    bedge(rowmod,4) = flaglim(ipoint);
end  %End of FOR

%Complete "bedge" with number of elements and fill "inedge".

%"inaux" is a counter of "inedge" rows because we do not know how many rows
%we will produce in this matrix
inaux = 1;

%Swept all elements of "elem" (rows)
for ielem = 1:nelem
    %Get the amount of edges in each element.
    amountedges = sum(elem(ielem,1:4) ~= 0);        
    %Swept all nodes of each element (columns)
    for inode = 1:amountedges
        %"next" is a variable which search the neighbour node in the
        %"elem" matrix. When inode is 4 (quadrangle mesh), "next" 
        %receives 1 because the neighbour of node 4 is the node 1. 
        %In any other situation the neighbour node is simply inode + 1 
        next = (inode == amountedges) + (inode + 1)*(inode < amountedges);
        %The same logical for "behaind"
        behaind = (inode == 1)*amountedges + (inode > 1)*(inode - 1);
            
        %------------------------------------------------------------------
        %>> When the edge belongs to boundary <<
            
        %Obtain the "bedge"'s row which contain "inode" and "next"
        i = all(elem(ielem,inode) == bedge(:,1:2) | elem(ielem,next) == ...
            bedge(:,1:2),2);

        %Verify if there is a common row between "findbedgerow1" 
        %and "findbedgerow2"
        if any(i)
            %If there is coincidence between nodes which are
            %conecteds to node ielem,inode and the nodes which
            %belong to boundary (obtained by *.msh file), the third
            %column of "bedge" receives the index which corresponds
            %to element in analisys.
            bedge(i,3) = ielem;
                
        %------------------------------------------------------------------
        %>> When the edge does not belongs to boundary <<
            
        %The couple of nodes which do not belong to "bedge" probably
        %belongs to "inedge". This ELSE attribute the couple of nodes to
        %"inedge". Before that, some conditions must be satisfy.
        else
            %Define the "inode" coordinate
            inodecoord = coord(elem(ielem,inode),:);
            %Get two vectors
            vecnext = coord(elem(ielem,next),:) - inodecoord;
            vecbehind =  coord(elem(ielem,behaind),:) - inodecoord;
            
            %Define the angle between the edges evaluated.
            angbtweenedges = acosd(dot(vecnext,vecbehind)/...
                (norm(vecnext)*norm(vecbehind)));
            %Get an angle condition. It is used because some edges form
            %angles near to 180 degrees. In order avoid ill interpretation
            %by "preprocessor", when the angle is near to 180, the way of
            %element is tuned counterclockwise.
            angcond = ((angbtweenedges/180) <= 0.99);

            %Get the cross product.
            pointsign = cross(vecnext,vecbehind);
            %Attribute just the cross "k" component.
            pointsign = pointsign(3)*angcond;
                            
            %Verify if couple of nodes already were contabilized. Case
            %yes, the element associate is a right element.
             
            %Obtain the "inedge"'s row which contain "inode" and "next"
            j = all(elem(ielem,inode) == inedge(:,1:2) | ...
                elem(ielem,next) == inedge(:,1:2),2);
            
            %Verify if the couple of nodes already were evaluated AND
            %if the node associated to "inode" is bigger than the node
            %associated to "next". In this case the element "ielem"
            %must be an element to right.
            if any(j) && elem(ielem,inode) > elem(ielem,next)
                %Define the column
                column = 4*(pointsign >= 0) + 3*(pointsign < 0); 
                %Attribute the element to column according to sign of
                %the "pointsign"
                inedge(j,column) = ielem;
            %The couple of nodes were evaluated but the node associated 
            %to "inode" is lower than the node associated to "next". In 
            %this case the element "ielem" is a left element.
            elseif any(j) && elem(ielem,inode) < elem(ielem,next)
                %Define the column
                column = 3*(pointsign >= 0) + 4*(pointsign < 0); 
                %Attribute the element to column according to sign of
                %the "pointsign"
                inedge(j,column) = ielem;
            %In case of the couple does not be already stored, Although
            %the node associated with "inode" is major than node
            %associated with "next". The "ielem" go to fourth column
            %too.
            elseif any(j) == 0 && elem(ielem,inode) > elem(ielem,next)      
                %Attribute the lower node to first column and the 
                %bigger node to second column
                inedge(inaux,1:2) = sort([elem(ielem,inode) ...
                    elem(ielem,next)]);
                %Define the column
                column = 4*(pointsign >= 0) + 3*(pointsign < 0); 
                %Attribute the element to column according to sign of
                %the "pointsign"
                inedge(inaux,column) = ielem;
                %Increment "inaux"
                inaux = inaux + 1;
            %The couple of nodes were never evaluated but the node
            %associated to "inode" is minor than node associated to 
            %"next". The element "ielem" go to third col. (left elem.)
            elseif  any(j) == 0 && elem(ielem,inode) < elem(ielem,next)
                %Attribute the lower node to first column and the 
                %bigger node to second column
                inedge(inaux,1:2) = sort([elem(ielem,inode) ...
                    elem(ielem,next)]);
                %Define the column
                column = 3*(pointsign >= 0) + 4*(pointsign < 0); 
                %Attribute the element to column according to sign of
                %the "pointsign"
                inedge(inaux,column) = ielem;
                %Increment "inaux"
                inaux = inaux + 1;
            end  %End of IF (fill "inedge")
        end  %End of IF ("bedge" and "inedge")
    end  %End of FOR (swept the vertices in each element)
end  %End of FOR (build "bedge" and "inedge")

%Clear matrices
clear getboundata bedgeaux;
end


